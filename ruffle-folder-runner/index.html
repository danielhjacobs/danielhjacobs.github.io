<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Local folder â†’ Ruffle runner</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; margin: 18px; }
    input, button { font: inherit; }
    #status { margin-top: 12px; white-space: pre-wrap; font-size: 13px; }
    #frame { width: 100%; height: 80vh; border: 1px solid #ccc; margin-top: 12px; }
    .files-list { max-height: 120px; overflow: auto; border: 1px dashed #ddd; padding: 8px; font-size: 12px; }
  </style>
</head>
<body>
  <h2>Local folder runner â€” upload a site with SWFs and assets</h2>
  <p>
    Choose the folder that contains <code>index.html</code> and all assets (SWF, JS, CSS, images).
    The script will convert files to blob URLs and serve a rewritten <code>index.html</code> inside an iframe.
  </p>
  <select id="ruffleSource">
    <option value="cdn">Use CDN (online)</option>
    <option value="local">Use local Ruffle from folder</option>
  </select>
  <input id="dirpicker" type="file" webkitdirectory />
  <button id="runBtn" disabled>Load selected folder</button>
  <div id="status"></div>
  <div style="margin-top:8px;">
    <strong>Files found:</strong>
    <div id="files" class="files-list"></div>
  </div>

  <iframe id="frame" title="preview"></iframe>

<script>
(async () => {
  const dirpicker = document.getElementById('dirpicker');
  const runBtn = document.getElementById('runBtn');
  const statusEl = document.getElementById('status');
  const filesEl = document.getElementById('files');
  const iframe = document.getElementById('frame');

  const ruffleSourceEl = document.getElementById('ruffleSource');

  // CDN URL for Ruffle: if this changes in the future you can replace with the correct one.
  // This should work for most releases; if you want a specific version, append @version:
  // e.g. https://unpkg.com/@ruffle-rs/ruffle@0.20.0/dist/ruffle.js
  const RUFFLE_CDN = 'https://unpkg.com/@ruffle-rs/ruffle';

  let fileList = []; // File objects from input
  let byPath = new Map(); // normalized relative path -> File

  function log(...args) {
    statusEl.textContent = (statusEl.textContent ? statusEl.textContent + '\n' : '') + args.join(' ');
  }

  function clearLog() {
    statusEl.textContent = '';
  }

  // Normalize path (strip leading ./ and normalize backslashes)
  function normPath(p) {
    return p.replace(/^\.\/+/, '').replace(/\\/g, '/');
  }

  dirpicker.addEventListener('change', (e) => {
    fileList = Array.from(e.target.files || []);
    byPath.clear();
    filesEl.textContent = '';
    if (!fileList.length) {
      runBtn.disabled = true;
      return;
    }
    fileList.forEach(f => {
      // file.webkitRelativePath usually exists when using webkitdirectory
      const rel = f.webkitRelativePath || f.name;
      const np = normPath(rel);
      byPath.set(np, f);
      const div = document.createElement('div');
      div.textContent = np;
      filesEl.appendChild(div);
    });
    runBtn.disabled = false;
    clearLog();
    log('Loaded', fileList.length, 'files from folder.');
  });

  // Helper: read whole file as text
  function readFileText(file) {
    return new Promise((res, rej) => {
      const r = new FileReader();
      r.onload = () => res(String(r.result));
      r.onerror = rej;
      r.readAsText(file);
    });
  }

  // Helper: read file as array buffer
  function readFileArrayBuffer(file) {
    return new Promise((res, rej) => {
      const r = new FileReader();
      r.onload = () => res(r.result);
      r.onerror = rej;
      r.readAsArrayBuffer(file);
    });
  }

  // Helper: create data URI for a file
  async function fileToDataUri(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => {
        const mime = file.type || 'application/octet-stream';
        // Encode as base64 if binary (ArrayBuffer) or leave as text
        if (mime.startsWith('text/') || mime === 'application/javascript' || mime === 'application/json') {
          // Text files can be embedded directly
          resolve(`data:${mime};charset=utf-8,${encodeURIComponent(reader.result)}`);
        } else {
          // Binary: base64
          const base64 = btoa(
            new Uint8Array(reader.result)
              .reduce((data, byte) => data + String.fromCharCode(byte), '')
          );
          resolve(`data:${mime};base64,${base64}`);
        }
      };
      reader.onerror = reject;

      if (file.type.startsWith('text/') || file.type === 'application/javascript' || file.type === 'application/json') {
        reader.readAsText(file);
      } else {
        reader.readAsArrayBuffer(file);
      }
    });
  }

  // Resolve a possibly relative URL against base directory (both are path-like)
  // baseDir is like "site/subdir/" or "" (root). urlValue is the attribute value.
  function resolveRelativeUrl(baseDir, urlValue) {
    if (!urlValue) return urlValue;
    // if absolute URL already or protocol or data: or blob: or //, just return null (we won't replace)
    if (/^(https?:|data:|blob:|\/\/|mailto:|tel:)/i.test(urlValue)) return null;
    // Remove any leading './'
    const raw = urlValue.replace(/^\.\//, '');
    // If urlValue begins with '/', treat it as absolute path root (strip leading '/')
    const path = urlValue.startsWith('/') ? raw.replace(/^\//, '') : (baseDir ? (baseDir + raw) : raw);
    // Normalize segments like ../
    const parts = path.split('/');
    const stack = [];
    for (const part of parts) {
      if (part === '' || part === '.') continue;
      if (part === '..') {
        if (stack.length) stack.pop();
      } else {
        stack.push(part);
      }
    }
    return stack.join('/');
  }

  // Rewrite CSS text url(...) occurrences to blob URLs using the mapping
  // mapping: object path -> blobUrl
  function rewriteCssUrls(cssText, baseDir, mapping) {
    // regex to match url(...) and capture path inside
    return cssText.replace(/url\(\s*(['"]?)([^'")]+)\1\s*\)/g, (m, q, path) => {
      // skip data:, http(s):, blob:, //, about:
      if (/^(data:|https?:|blob:|\/\/|about:)/i.test(path)) return m;
      const resolved = resolveRelativeUrl(baseDir, path);
      if (!resolved) return m;
      const blob = mapping.get(resolved);
      if (!blob) {
        // not found, leave as-is
        return m;
      }
      return `url("${blob}")`;
    });
  }

  async function buildAndLaunch() {
    clearLog();
    log('Preparing...');

    if (!byPath.size) {
      log('No files selected.');
      return;
    }

    // find index.html (case-insensitive). prefer root index.html, else first found.
    let indexPath = null;
    for (const p of byPath.keys()) {
      if (/(^|\/)index\.html$/i.test(p)) {
        // Count slashes: "folder/index.html" should have exactly one
        const slashCount = (p.match(/\//g) || []).length;
        if (slashCount === 1) {
          indexPath = p; // top-level index.html
          break;
        }
        if (!indexPath) indexPath = p; // fallback: any index.html
      }
    }
    if (!indexPath) {
      log('No index.html found in uploaded folder.');
      return;
    }
    log('Using index:', indexPath);

    // Create a mapping of normalized path -> blobUrl or rewritten blob for CSS files.
    const blobMap = new Map();

    // First pre-create blob URLs for binary files (images, swf, fonts, etc.) so we can reference them immediately
    // We'll handle CSS and HTML files specially (so we can rewrite inside them).
    for (const [p, file] of byPath.entries()) {
      const lower = p.toLowerCase();
	  // Skip only HTML files that we will rewrite later (index.html itself)
      if (lower === indexPath.toLowerCase() || lower.endsWith('.css') || lower.endsWith('.js')) {
        continue;
      }
      // Create blob URL directly
      const url = await fileToDataUri(file);
      blobMap.set(p, url);
    }

    // Prepare handling for CSS files: read them, rewrite url(...) references, produce new blob URLs
    for (const [p, file] of byPath.entries()) {
      if (!p.toLowerCase().endsWith('.css')) continue;
      try {
        const cssText = await readFileText(file);
        // baseDir for this CSS: directory where file is located
        const idx = p.lastIndexOf('/');
        const baseDir = idx >= 0 ? p.slice(0, idx + 1) : '';
        const rewritten = rewriteCssUrls(cssText, baseDir, blobMap);
        // create a new blob with rewritten CSS and store blob URL
        const newBlob = new Blob([rewritten], { type: 'text/css' });
        const url = URL.createObjectURL(newBlob);
        blobMap.set(p, url);
      } catch (err) {
        log('Failed to read/rewire CSS', p, err);
      }
    }

    // Prepare JS files: we can just create blob URLs for them (no rewriting) â€” but they might import relative resources.
    // For simplicity, create blob URLs for JS files too (we could rewrite import urls if needed).
    for (const [p, file] of byPath.entries()) {
      if (!p.toLowerCase().endsWith('.js')) continue;
      const url = await fileToDataUri(file);
      blobMap.set(p, url);
    }

    // SVG may contain href/url references to other assets â€” handling that is possible but omitted here.
    // Now read the index.html, parse and rewrite its resource references
    let indexHtmlText = await readFileText(byPath.get(indexPath));
    // We'll use DOMParser to reliably rewrite tags
    const parser = new DOMParser();
    const doc = parser.parseFromString(indexHtmlText, 'text/html');

    // Insert a comment to indicate this file was rewritten
    doc.head.insertAdjacentHTML('afterbegin', '<meta name="ruffle-local-runner" content="rewritten">');

    // Remove existing Ruffle scripts (local ruffle.js, unpkg, jsfiddle, cdn)
    const existingRuffleScripts = Array.from(doc.querySelectorAll('script[src]'));
    for (const s of existingRuffleScripts) {
      const src = s.getAttribute('src') || '';
      const lower = src.toLowerCase();
      if (
        ruffleSourceEl.value === 'cdn' &&
        (lower.includes('ruffle.js') ||                 // local or generic filename
        lower.includes('unpkg.com/@ruffle-rs/ruffle') || // unpkg CDN
        lower.includes('cdn.jsdelivr.net/npm/@ruffle-rs/ruffle')) // JSDelivr CDN
      ) {
        s.remove();
      }
    }

    // Inject the Ruffle CDN script into head (before other scripts), ensure it loads as classic script
    if (ruffleSourceEl.value === 'cdn') {
      const ruffleScriptEl = doc.createElement('script');
      ruffleScriptEl.src = RUFFLE_CDN;
      ruffleScriptEl.defer = false;
      doc.head.appendChild(ruffleScriptEl);
      log('ðŸŒ Using CDN Ruffle.');
    }
    if (ruffleSourceEl.value === 'local') {
      log('Using local Ruffle.');
    }

    // Helper to map attribute values for elements
    function mapAttr(el, attrName, baseDir) {
      const v = el.getAttribute(attrName);
      if (!v) return;
      // If v is absolute or data/blob, skip
      if (/^(https?:|data:|blob:|\/\/|mailto:|tel:)/i.test(v)) return;
      if (attrName === 'src' && v.endsWith('.swf')) {
        el.setAttribute('type', 'application/x-shockwave-flash');
      }
      const resolved = resolveRelativeUrl(baseDir, v);
      if (!resolved) return;
      const newUrl = blobMap.get(resolved);
      if (newUrl) el.setAttribute(attrName, newUrl);
    }

    // Base directory for index (the directory containing index.html)
    const idxSlash = indexPath.lastIndexOf('/');
    const indexBase = idxSlash >= 0 ? indexPath.slice(0, idxSlash + 1) : '';

    // Rewrite tags:
    // img[src], script[src], iframe[src], audio[src], video[src], source[src], track[src], embed[src], object[data], link[href]
    const tagAttrPairs = [
      ['img', 'src'],
      ['script', 'src'],
      ['iframe', 'src'],
      ['audio', 'src'],
      ['video', 'src'],
      ['source', 'src'],
      ['track', 'src'],
      ['embed', 'src'],
      ['object', 'data'],
      ['link', 'href'],
      // For <a href> we generally don't rewrite (links to pages) â€” skip unless required.
    ];

    for (const [tag, attr] of tagAttrPairs) {
      const els = Array.from(doc.querySelectorAll(`${tag}[${attr}]`));
      for (const el of els) {
        // Compute el-specific base directory: some tags might be in subdirs but relative URLs in index are relative to indexBase (and to tag's location if loaded from different base).
        // We'll use indexBase for HTML rewriting.
        mapAttr(el, attr, indexBase);
      }
    }

    // Special handling: <param name="movie" value="..."> inside <object> or <embed>
    const params = Array.from(doc.querySelectorAll('param[name][value]'));
    for (const p of params) {
      const name = p.getAttribute('name').toLowerCase();
      if (name === 'movie' || name === 'src' || name === 'data') {
        mapAttr(p, 'value', indexBase);
      }
    }

    // Rewrite inline styles url(...) in style attributes
    const styledEls = Array.from(doc.querySelectorAll('[style]'));
    for (const el of styledEls) {
      const style = el.getAttribute('style');
      if (style && /url\(/i.test(style)) {
        const rewritten = rewriteCssUrls(style, indexBase, blobMap);
        el.setAttribute('style', rewritten);
      }
    }

    // Rewrite <style>...</style> blocks
    const styleBlocks = Array.from(doc.querySelectorAll('style'));
    for (const s of styleBlocks) {
      const cssText = s.textContent || '';
      if (!cssText) continue;
      const rewritten = rewriteCssUrls(cssText, indexBase, blobMap);
      s.textContent = rewritten;
    }

    // If there are <link rel="stylesheet"> tags, their href should already have been replaced above (mapAttr).
    // But if some CSS files referenced other assets, we already rewrote them when we preprocessed CSS.

    // Finally, ensure Ruffle instantiation: append a small inline script that calls instantiateAll after ruffle loads.
    // We also give RufflePlayer a small configuration if desired.
    const finalizeScript = doc.createElement('script');
    finalizeScript.type = 'text/javascript';

	// Strip first path segment from keys
	const strippedEntries = Array.from(blobMap.entries()).map(([key, value]) => {
	  const idx = key.indexOf("/");
	  const newKey = idx >= 0 ? key.slice(idx + 1) : key;
	  return [newKey, value];
	});

	// Serialize for injection into iframe
	const blobMapEntries = JSON.stringify(strippedEntries);

    finalizeScript.textContent = `
      (function(){
        const isLocal = ${ruffleSourceEl.value === 'local'};
        // === BEGIN blob redirect patch ===
        const blobMap = new Map(${blobMapEntries});
        const base = document.baseURI;

  // Patch dynamic imports used by Webpack
  if (isLocal) {
  const originalCreateElement = document.createElement;
  document.createElement = function(tagName, options) {
    const el = originalCreateElement.call(this, tagName, options);
    if (tagName === "script") {
      const originalSrcSetter = Object.getOwnPropertyDescriptor(HTMLScriptElement.prototype, "src").set;
      Object.defineProperty(el, "src", {
        set(value) {
          // Look up the data URI by the chunk name
		  const keys = Array.from(blobMap.keys());
          const key = keys.find(k => k.endsWith(value) || k.endsWith("/" + value));
          if (key) {
            const dataUri = blobMap.get(key);
            originalSrcSetter.call(this, dataUri);
          } else {
            originalSrcSetter.call(this, value);
          }
        },
        get() {
          return this.getAttribute("src");
        },
        configurable: true
      });
    }
    return el;
  };
  }

        // Patch fetch()
        const originalFetch = window.fetch;
        function normalizeUrl(url) {
          let href = typeof url === "string" ? url : url.href;

          try {
            const u = new URL(href);

            const segments = u.pathname.split('/').filter(Boolean);

            if (segments.length === 1) {
              return segments[0];
            }

            return href;
          } catch (e) {
            return href;
          }
        }
        // Helper to resolve redirect target if any
        function resolveBlobRedirect(url) {
          try {
            url = normalizeUrl(url);
            const absUrl = new URL(url, base).href;
            for (const [key, blobUrl] of blobMap.entries()) {
              const absUrlNoQuery = String(absUrl).split(/[?#]/)[0];
              const pathToUploadedBlob = base.substring(0, base.lastIndexOf('/')) + "/" + key;
              if (
                absUrlNoQuery === pathToUploadedBlob ||
                (
                  isLocal &&
                  absUrlNoQuery.endsWith(".wasm") &&
                  absUrlNoQuery.endsWith(key.replace(/^.*[\\/]/, ''))
                )
              ) {
                console.log("ðŸ”€ Redirecting fetch from", absUrl, "â†’", blobUrl);
                return blobUrl;
              }
            }
          } catch (e) {
            console.warn("URL resolution failed for", url, e);
          }
          return null;
        }

        // Patch fetch safely
        window.fetch = function(input, init) {
          let url = input;

          // If input is a Request object, preserve it
          if (input instanceof Request) {
            const redirected = resolveBlobRedirect(input.url);
            if (redirected) {
              // Clone request with new URL but same properties
              const newRequest = new Request(redirected, input);
              return originalFetch.call(this, newRequest, init);
            }
            return originalFetch.call(this, input, init);
          }

          // If input is a string
          const redirected = resolveBlobRedirect(input);
          if (redirected) {
            url = redirected;
          }

          return originalFetch.call(this, url, init);
        };
        // === END blob redirect patch ===
        function tryInstantiate() {
          if (window.RufflePlayer && typeof window.RufflePlayer.instantiateAll === 'function') {
            try {
              window.RufflePlayer.configure && window.RufflePlayer.configure({ use_swfobject: false });
            } catch(e){}
            window.RufflePlayer.instantiateAll();
          } else {
            // try again
            setTimeout(tryInstantiate, 200);
          }
        }
        tryInstantiate();
      })();
    `;
    const baseElement = document.createElement('base');
    baseElement.href =  document.location.href;
    doc.body.appendChild(baseElement);
    doc.body.appendChild(finalizeScript);

    // Now serialize the modified document to text
    const finalHtml = '<!doctype html>\n' + doc.documentElement.outerHTML;

    log('Launching rewritten page into iframe...');
    iframe.srcdoc = finalHtml;

    log('Done. If SWFs do not start automatically, check console in the preview iframe (right-click â†’ Inspect).');
    log('Note: blob URLs will be kept alive while this page is open. Refreshing this page will free them.');
  }

  runBtn.addEventListener('click', () => {
    runBtn.disabled = true;
    buildAndLaunch().catch(err => {
      log('Error:', err && err.message ? err.message : String(err));
    }).finally(() => {
      runBtn.disabled = false;
    });
  });

})();
</script>
</body>
</html>
