<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Local folder â†’ Ruffle runner</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
  :root {
    --ruffle-light-blue: #546da3;
    --ruffle-blue: #37528c;
    --ruffle-dark-blue: #184778;
    --ruffle-orange: #ffad33;
    --ruffle-dark-orange: #966214;
  }
  body {
    background-color: var(--ruffle-blue);
    color: var(--ruffle-orange);
  }
  .panel {
    margin: 0 auto;
    max-width: 700px;
  }

  .row {
    display: flex;
    gap: 1rem;
    align-items: center;
    margin-bottom: 1rem;
  }

  label {
    font-weight: bold;
  }

  select,
  input[type="file"],
  button {
    padding: 0.4rem 0.6rem;
    border-radius: 6px;
    border: 1px solid var(--ruffle-light-blue);
    background: var(--ruffle-light-blue);
    color: white;
  }

  button:not(:disabled) {
    cursor: pointer;
  }

  button:disabled {
    color: lightgray;
  }

  details {
    border-radius: 8px;
    border: 1px solid var(--ruffle-orange);
    margin-top: 1rem;
    padding: 0.5rem 1rem;
  }

  details summary {
    cursor: pointer;
    font-weight: bold;
  }

  pre {
    background: var(--ruffle-light-blue);
    border-radius: 6px;
    padding: 0.75rem;
    font-family: monospace;
    font-size: 0.9rem;
    overflow-x: auto;
    max-height: 200px;
  }

  .files-list {
    max-height: 200px;
    overflow-y: auto;
  }
  .or-divider {
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    margin: 0.5rem 0;
    position: relative;
  }

  .or-divider::before,
  .or-divider::after {
    content: "";
    flex: 1;
    height: 1px;
    background: var(--ruffle-orange);
    margin: 0 0.75rem;
  }
  #frame {
    width: 100%;
    height: 77vh;
    border: 1px solid var(--ruffle-orange);
    margin-top: 12px;
  }
  h2 {
    text-align: center;
    font-size: 20px;
  }
  </style>
</head>
<body>
  <h2>Upload SWFs &amp; assets</h2>
  <details>
    <summary>Upload Options</summary>
    <div class="panel">
      <p>
        Choose a folder that contains <code>index.html</code> and all assets or choose a Ruffle bundle.
        The script will convert files to data URLs and serve a rewritten <code>index.html</code> in an iframe.
      </p>
      <div class="row">
        <label for="ruffleSource">Source:</label>
        <select id="ruffleSource">
          <option value="cdn">Use CDN (online)</option>
          <option value="local">Use local Ruffle from folder</option>
        </select>
      </div>
      <div id="ruffleVersionRow" class="row" style="display: none;">
        <label for="ruffleVersion">Version:</label>
        <select id="ruffleVersion"></select>
      </div>
      <div class="row">
        <label for="dirpicker">Folder:</label>
        <input id="dirpicker" type="file" webkitdirectory />
      </div>
      <div class="or-divider">
        <span>or</span>
      </div>
      <div class="row">
        <label for="zipPicker">Ruffle Bundle:</label>
        <input id="zipPicker" type="file" accept=".ruf" />
      </div>
      <button id="runBtn" disabled>Load Selected Folder or Bundle</button>
    </div>
  </details>

  <details>
    <summary>Status Log</summary>
    <pre id="status"></pre>
  </details>

  <details>
    <summary>Files Found</summary>
    <ul id="files" class="files-list"></ul>
  </details>

  <iframe id="frame" title="preview"></iframe>
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
<script>
(async () => {
  const dirpicker = document.getElementById('dirpicker');
  const runBtn = document.getElementById('runBtn');
  const statusEl = document.getElementById('status');
  const filesEl = document.getElementById('files');
  const iframe = document.getElementById('frame');
  const zipPicker = document.getElementById("zipPicker");
  const versionDropdown = document.getElementById("ruffleVersion");
  const versionRow = document.getElementById("ruffleVersionRow");

  const ruffleSourceEl = document.getElementById('ruffleSource');
  function versionToDate(version) {
    return version.split(".").slice(-3).map((el) => el.padStart(2, "0")).join("-");
  }
  function makeSelectVersion(versions) {
    versionDropdown.add(new Option("-- Optionally choose version --", ""));
    versions.forEach((version) => versionDropdown.add(new Option(versionToDate(version), version)));
    if (ruffleSourceEl.value === "cdn") {
      versionRow.style.display = "flex";
    }
  }
  ruffleSourceEl.addEventListener("change", () => {
    versionRow.style.display = ruffleSourceEl.value === "cdn" ? "flex" : "none";
  });
  const jsdelivrAPIURL = "https://data.jsdelivr.com/v1/package/npm/@ruffle-rs/ruffle";
  fetch(jsdelivrAPIURL)
    .then((response) => response.json())
    .then((json) => makeSelectVersion(json['versions']));

  // CDN URL for Ruffle: if this changes in the future you can replace with the correct one.
  // This should work for most releases; if you want a specific version, append @version:
  // e.g. https://unpkg.com/@ruffle-rs/ruffle@0.20.0/dist/ruffle.js
  const UNPKG_CDN = 'https://unpkg.com/@ruffle-rs/ruffle';

  let fileList = []; // File objects from input
  let byPath = new Map(); // normalized relative path -> File

  function log(...args) {
    statusEl.textContent = (statusEl.textContent ? statusEl.textContent + '\n' : '') + args.join(' ');
  }

  function clearLog() {
    statusEl.textContent = '';
  }

  // Normalize path (strip leading ./ and normalize backslashes)
  function normPath(p) {
    return p.replace(/^\.\/+/, '').replace(/\\/g, '/');
  }

  zipPicker.addEventListener("change", async (e) => {
    const file = e.target.files[0];
    if (!file) return;

    runBtn.disabled = true;
    clearLog();
    log("Reading ZIP file...");

    try {
      const arrayBuffer = await readFileArrayBuffer(file);
      const zip = await JSZip.loadAsync(arrayBuffer);
      byPath.clear();
      filesEl.textContent = "";

      const entries = Object.entries(zip.files);
      fileList = [];

      for (const [name, entry] of entries) {
        if (entry.dir) continue;
        const np = normPath(name);
        const blob = await entry.async("blob");
        const fileObj = new File([blob], np, { type: blob.type || "application/octet-stream" });
        byPath.set(np, fileObj);
        fileList.push(fileObj);

        const li = document.createElement("li");
        li.textContent = np;
        filesEl.appendChild(li);
      }

      log("Extracted", fileList.length, "files from ZIP.");
      runBtn.disabled = false;
    } catch (err) {
      log("Failed to read ZIP:", err);
    }
    ruffleSourceEl.value = "cdn";
  });

  dirpicker.addEventListener('change', (e) => {
    fileList = Array.from(e.target.files || []);
    byPath.clear();
    filesEl.textContent = '';
    if (!fileList.length) {
      runBtn.disabled = true;
      return;
    }
    fileList.forEach(f => {
      // file.webkitRelativePath usually exists when using webkitdirectory
      const rel = f.webkitRelativePath || f.name;
      const np = normPath(rel);
      byPath.set(np, f);
      const li = document.createElement('li');
      li.textContent = np;
      filesEl.appendChild(li);
    });
    runBtn.disabled = false;
    clearLog();
    log('Loaded', fileList.length, 'files from folder.');
  });

  // Helper: read whole file as text
  function readFileText(file) {
    return new Promise((res, rej) => {
      const r = new FileReader();
      r.onload = () => res(String(r.result));
      r.onerror = rej;
      r.readAsText(file);
    });
  }

  // Helper: read file as array buffer
  function readFileArrayBuffer(file) {
    return new Promise((res, rej) => {
      const r = new FileReader();
      r.onload = () => res(r.result);
      r.onerror = rej;
      r.readAsArrayBuffer(file);
    });
  }

  // Helper: create data URI for a file
  async function fileToDataUri(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => {
        const mime = file.type || 'application/octet-stream';
        // Encode as base64 if binary (ArrayBuffer) or leave as text
        if (mime.startsWith('text/') || mime === 'application/javascript' || mime === 'application/json') {
          // Text files can be embedded directly
          resolve(`data:${mime};charset=utf-8,${encodeURIComponent(reader.result)}`);
        } else {
          // Binary: base64
          const base64 = btoa(
            new Uint8Array(reader.result)
              .reduce((data, byte) => data + String.fromCharCode(byte), '')
          );
          resolve(`data:${mime};base64,${base64}`);
        }
      };
      reader.onerror = reject;

      if (file.type.startsWith('text/') || file.type === 'application/javascript' || file.type === 'application/json') {
        reader.readAsText(file);
      } else {
        reader.readAsArrayBuffer(file);
      }
    });
  }

  // Resolve a possibly relative URL against base directory (both are path-like)
  // baseDir is like "site/subdir/" or "" (root). urlValue is the attribute value.
  function resolveRelativeUrl(baseDir, urlValue) {
    if (!urlValue) return urlValue;
    // if absolute URL already or protocol or data: or blob: or //, just return null (we won't replace)
    if (/^(https?:|data:|blob:|\/\/|mailto:|tel:)/i.test(urlValue)) return null;
    // Remove any leading './'
    const raw = urlValue.replace(/^\.\//, '');
    // If urlValue begins with '/', treat it as absolute path root (strip leading '/')
    const path = urlValue.startsWith('/') ? raw.replace(/^\//, '') : (baseDir ? (baseDir + raw) : raw);
    // Normalize segments like ../
    const parts = path.split('/');
    const stack = [];
    for (const part of parts) {
      if (part === '' || part === '.') continue;
      if (part === '..') {
        if (stack.length) stack.pop();
      } else {
        stack.push(part);
      }
    }
    return stack.join('/');
  }

  // Rewrite CSS text url(...) occurrences to data URLs using the mapping
  // mapping: object path -> dataUrl
  function rewriteCssUrls(cssText, baseDir, mapping) {
    // regex to match url(...) and capture path inside
    return cssText.replace(/url\(\s*(['"]?)([^'")]+)\1\s*\)/g, (m, q, path) => {
      // skip data:, http(s):, blob:, //, about:
      if (/^(data:|https?:|blob:|\/\/|about:)/i.test(path)) return m;
      const resolved = resolveRelativeUrl(baseDir, path);
      if (!resolved) return m;
      const dataUri = mapping.get(resolved);
      if (!dataUri) {
        // not found, leave as-is
        return m;
      }
      return `url("${dataUri}")`;
    });
  }

  async function buildAndLaunch() {
    clearLog();
    log('Preparing...');

    if (!byPath.size) {
      log('No files selected.');
      return;
    }

    // find index.html (case-insensitive). prefer root index.html, else first found.
    let indexPath = null;
    for (const p of byPath.keys()) {
      if (/(^|\/)index\.html$/i.test(p)) {
        // Count slashes: "folder/index.html" should have exactly one
        const slashCount = (p.match(/\//g) || []).length;
        if (slashCount === 1) {
          indexPath = p; // top-level index.html
          break;
        }
        if (!indexPath) indexPath = p; // fallback: any index.html
      }
    }
    let indexHtmlText = null;

    if (!indexPath) {
      // Fallback: check for ruffle-bundle.toml
      const tomlPath = Array.from(byPath.keys()).find(p => p.toLowerCase().endsWith('ruffle-bundle.toml'));
      if (tomlPath) {
        log('Found ruffle-bundle.toml, creating fake index.html.');

        try {
          const tomlText = await readFileText(byPath.get(tomlPath));
          // Simple regex to extract url = "file:///..." or url="..."
          const match = tomlText.match(/url\s*=\s*["'](file:\/\/\/[^"']+)["']/i);
          if (match) {
            const swfUrl = match[1].replace(/^file:\/\/\//, '');
            const playerMatch = tomlText.match(/\[player\][\s\S]*?(?=\[|$)/i);
            const tomlToConfigMap = {
              align: "salign",
              force_align: "forceAlign",
              scale_mode: "scale",
              force_scale_mode: "forceScale",
              upgrade_http_to_https: "upgradeToHttps",
              version: "playerVersion",
              runtime: "playerRuntime",
              frame_rate: "frameRate",
              quality: "quality",
              letterbox: "letterbox",
              script_timeout: "maxExecutionDuration",
              base_url: "base",
          };

          const config = {};
          const params = {};
		  let allowScript = false;

          if (playerMatch) {
            for (const line of playerMatch[0].split("\n")) {
              const m = line.match(/^\s*([\w_]+)\s*=\s*["']?([^"']+)["']?/);
              // Load behavior desktop only per https://github.com/ruffle-rs/ruffle/pull/8009#issuecomment-1283092686
              // Dummy external interface is desktop only: https://github.com/ruffle-rs/ruffle/pull/11439
              // Spoof URL is desktop only: https://github.com/ruffle-rs/ruffle/pull/8185
              if (m && !["load_behavior", "spoof_url", "mock_external_interface"].includes(m[1])) {
                const tomlKey = m[1];
                const mappedKey = tomlToConfigMap[tomlKey] || tomlKey;
                let val = m[2];
                switch (tomlKey) {
                  case "align": {
                    const alignMap = {
                      "bottom": "B",
                      "bottom_left": "BL",
                      "bottom_right": "BR",
                      "left": "L",
                      "right": "R",
                      "top": "T",
                      "top_left": "TL",
                      "top_right": "TR",
                      "center": "",
                    };
                    val = alignMap[val] ?? val;
                    break;
                  }

                  case "force_align":
                  case "force_scale_mode":
                  case "upgrade_http_to_https":
                    val = val.trim().toLowerCase() === "true";
                    break;

                  case "scale_mode": {
                    const scaleMap = {
                      "exact_fit": "exactfit",
                      "no_border": "noborder",
                      "no_scale": "noscale",
                      "show_all": "showAll",
                    };
                    val = scaleMap[val] ?? val;
                    break;
                  }

                  case "version":
                  case "script_timeout":
                  case "frame_rate":
                    val = parseFloat(val);
                    break;

                  case "runtime": {
                    const runtimeMap = {
                      flash_player: "flashPlayer",
                      air: "air",
                    };
                    val = runtimeMap[val] ?? val;
                    break;
                  }

                  default:
                    // leave it
                    break;
                }

                config[mappedKey] = val;
              }
              // This isn't an exact match, but should match the desired functionality
              if (m && "mock_external_interface" === m[1]) {
                const val = m[2];
                allowScript = val.trim().toLowerCase() === "true";
              }
            }
          }
          let flashVars = "";
          const paramsMatch = tomlText.match(/\[player\.parameters\][\s\S]*?(?=\[|$)/i);
          if (paramsMatch) {
            for (const line of paramsMatch[0].split("\n")) {
              const m = line.match(/^\s*([\w_]+)\s*=\s*["']([^"']+)["']/);
              if (m) params[m[1]] = m[2];
            }
			flashVars = Object.entries(params).map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(value)}`).join("&");
          }
          indexPath = '__generated_index.html';
          indexHtmlText = `
<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>${swfUrl}</title>${
    Object.keys(config).length
      ? `
  <script>
    window.RufflePlayer = window.RufflePlayer || {};
    window.RufflePlayer.config = {
      ...window.RufflePlayer.config,
      ${Object.entries(config)
        .map(([k, v]) => `${JSON.stringify(k)}: ${JSON.stringify(v)}`)
        .join(",\n      ")}
    };
  <\/script>`
      : ""
  }
</head>
<body style="margin:0;background:var(--ruffle-blue);display:flex;align-items:center;justify-content:center;height:100vh;">
  <script>
    document.addEventListener("DOMContentLoaded", async () => {
      const ruffle = window.RufflePlayer?.newest?.();
      if (!ruffle) {
        console.error("Ruffle not loaded properly.");
        return;
      }

      const player = ruffle.createPlayer();
      player.style.width = "100%";
      player.style.height = "100%";
      const body = document.querySelector("body");
      body.appendChild(player);

      try {
        player.ruffle().load({
          url: ${JSON.stringify(swfUrl)},
          parameters: ${JSON.stringify(flashVars)},
          allowScriptAccess: ${allowScript}
        });
      } catch (e) {
        console.error("Failed to load SWF:", e);
      }
    });
  <\/script>
</body>
</html>`;
            // Create a virtual File for consistency
            byPath.set(indexPath, new File([indexHtmlText], indexPath, { type: 'text/html' }));
          } else {
            log('ruffle-bundle.toml found but no valid "url =" line detected.');
            return;
          }
        } catch (err) {
          log('Error reading ruffle-bundle.toml:', err);
          return;
        }
      } else {
        log('No index.html or ruffle-bundle.toml found in uploaded folder or bundle.');
        return;
      }
    }

    if (!indexHtmlText) {
      indexHtmlText = await readFileText(byPath.get(indexPath));
    }
    log('Using index:', indexPath);

    // Create a mapping of normalized path -> dataUri or rewritten data for CSS files.
    const dataMap = new Map();

    // First pre-create data URLs for binary files (images, swf, fonts, etc.) so we can reference them immediately
    // We'll handle CSS and HTML files specially (so we can rewrite inside them).
    for (const [p, file] of byPath.entries()) {
      const lower = p.toLowerCase();
      // Skip only HTML files that we will rewrite later (index.html itself)
      if (lower === indexPath.toLowerCase() || lower.endsWith('.css') || lower.endsWith('.js')) {
        continue;
      }
      // Create data URL directly
      const url = await fileToDataUri(file);
      dataMap.set(p, url);
    }

    // Prepare handling for CSS files: read them, rewrite url(...) references, produce new data URLs
    for (const [p, file] of byPath.entries()) {
      if (!p.toLowerCase().endsWith('.css')) continue;
      try {
        const cssText = await readFileText(file);
        // baseDir for this CSS: directory where file is located
        const idx = p.lastIndexOf('/');
        const baseDir = idx >= 0 ? p.slice(0, idx + 1) : '';
        const rewritten = rewriteCssUrls(cssText, baseDir, dataMap);
        // create a new data URI with rewritten CSS
        const mime = 'text/css';
        const url = `data:${mime};charset=utf-8,${encodeURIComponent(rewritten)}`;
		dataMap.set(p, url);
      } catch (err) {
        log('Failed to read/rewire CSS', p, err);
      }
    }

    // Prepare JS files: we can just create data URLs for them (no rewriting) â€” but they might import relative resources.
    // For simplicity, create data URLs for JS files too (we could rewrite import urls if needed).
    for (const [p, file] of byPath.entries()) {
      if (!p.toLowerCase().endsWith('.js')) continue;
      const url = await fileToDataUri(file);
      dataMap.set(p, url);
    }

    // SVG may contain href/url references to other assets â€” handling that is possible but omitted here.
    // Now read the index.html, parse and rewrite its resource references
    // We'll use DOMParser to reliably rewrite tags
    const parser = new DOMParser();
    const doc = parser.parseFromString(indexHtmlText, 'text/html');

    // Insert a comment to indicate this file was rewritten
    doc.head.insertAdjacentHTML('afterbegin', '<meta name="ruffle-local-runner" content="rewritten">');

    // Remove existing Ruffle scripts (local ruffle.js, unpkg, jsfiddle, cdn)
    const existingRuffleScripts = Array.from(doc.querySelectorAll('script[src]'));
    for (const s of existingRuffleScripts) {
      const src = s.getAttribute('src') || '';
      const lower = src.toLowerCase();
      if (
        ruffleSourceEl.value === 'cdn' &&
        (lower.includes('ruffle.js') ||                 // local or generic filename
        lower.includes('unpkg.com/@ruffle-rs/ruffle') || // unpkg CDN
        lower.includes('cdn.jsdelivr.net/npm/@ruffle-rs/ruffle')) // JSDelivr CDN
      ) {
        s.remove();
      }
    }

    // Inject the Ruffle CDN script into head (before other scripts), ensure it loads as classic script
    if (ruffleSourceEl.value === 'cdn') {
      const ruffleScriptEl = doc.createElement('script');
      const version = versionDropdown.value;
      if (version) {
        const cdnURL = "https://cdn.jsdelivr.net/npm/@ruffle-rs/ruffle@" + version;
        try {
          const response = await fetch(cdnURL);
          if (response.ok) {
            ruffleScriptEl.src = cdnURL;
          } else {
            ruffleScriptEl.src = UNPKG_CDN;
          }
        } catch (error) {
          ruffleScriptEl.src = UNPKG_CDN;
        }
        doc.head.appendChild(ruffleScriptEl);
      } else {
        ruffleScriptEl.src = UNPKG_CDN;
        doc.head.appendChild(ruffleScriptEl);
      }
      log('ðŸŒ Using CDN Ruffle.');
    }
    if (ruffleSourceEl.value === 'local') {
      log('Using local Ruffle.');
    }

    // Helper to map attribute values for elements
    function mapAttr(el, attrName, baseDir) {
      const v = el.getAttribute(attrName);
      if (!v) return;
      // If v is absolute or data/blob, skip
      if (/^(https?:|data:|blob:|\/\/|mailto:|tel:)/i.test(v)) return;
      if (attrName === 'src' && v.endsWith('.swf')) {
        el.setAttribute('type', 'application/x-shockwave-flash');
      }
      const resolved = resolveRelativeUrl(baseDir, v);
      if (!resolved) return;
      const newUrl = dataMap.get(resolved);
      if (newUrl) el.setAttribute(attrName, newUrl);
    }

    // Base directory for index (the directory containing index.html)
    const idxSlash = indexPath.lastIndexOf('/');
    const indexBase = idxSlash >= 0 ? indexPath.slice(0, idxSlash + 1) : '';

    // Rewrite tags:
    // img[src], script[src], iframe[src], audio[src], video[src], source[src], track[src], embed[src], object[data], link[href]
    const tagAttrPairs = [
      ['img', 'src'],
      ['script', 'src'],
      ['iframe', 'src'],
      ['audio', 'src'],
      ['video', 'src'],
      ['source', 'src'],
      ['track', 'src'],
      ['embed', 'src'],
      ['object', 'data'],
      ['link', 'href'],
      // For <a href> we generally don't rewrite (links to pages) â€” skip unless required.
    ];

    for (const [tag, attr] of tagAttrPairs) {
      const els = Array.from(doc.querySelectorAll(`${tag}[${attr}]`));
      for (const el of els) {
        // Compute el-specific base directory: some tags might be in subdirs but relative URLs in index are relative to indexBase (and to tag's location if loaded from different base).
        // We'll use indexBase for HTML rewriting.
        mapAttr(el, attr, indexBase);
      }
    }

    // Special handling: <param name="movie" value="..."> inside <object> or <embed>
    const params = Array.from(doc.querySelectorAll('param[name][value]'));
    for (const p of params) {
      const name = p.getAttribute('name').toLowerCase();
      if (name === 'movie' || name === 'src' || name === 'data') {
        mapAttr(p, 'value', indexBase);
      }
    }

    // Rewrite inline styles url(...) in style attributes
    const styledEls = Array.from(doc.querySelectorAll('[style]'));
    for (const el of styledEls) {
      const style = el.getAttribute('style');
      if (style && /url\(/i.test(style)) {
        const rewritten = rewriteCssUrls(style, indexBase, dataMap);
        el.setAttribute('style', rewritten);
      }
    }

    // Rewrite <style>...</style> blocks
    const styleBlocks = Array.from(doc.querySelectorAll('style'));
    for (const s of styleBlocks) {
      const cssText = s.textContent || '';
      if (!cssText) continue;
      const rewritten = rewriteCssUrls(cssText, indexBase, dataMap);
      s.textContent = rewritten;
    }

    // If there are <link rel="stylesheet"> tags, their href should already have been replaced above (mapAttr).
    // But if some CSS files referenced other assets, we already rewrote them when we preprocessed CSS.

    // Finally, ensure Ruffle instantiation: append a small inline script that calls instantiateAll after ruffle loads.
    // We also give RufflePlayer a small configuration if desired.
    const finalizeScript = doc.createElement('script');
    finalizeScript.type = 'text/javascript';

    // Strip first path segment from keys
    const strippedEntries = Array.from(dataMap.entries()).map(([key, value]) => {
      const idx = key.indexOf("/");
      const newKey = idx >= 0 ? key.slice(idx + 1) : key;
      return [newKey, value];
    });

    // Serialize for injection into iframe
    const dataMapEntries = JSON.stringify(strippedEntries);

    finalizeScript.textContent = `
      (function(){
        const isLocal = ${ruffleSourceEl.value === 'local'};
        // === BEGIN data redirect patch ===
        const dataMap = new Map(${dataMapEntries});
        const base = document.baseURI;

  // Patch dynamic imports used by Webpack
  if (isLocal) {
  const originalCreateElement = document.createElement;
  document.createElement = function(tagName, options) {
    const el = originalCreateElement.call(this, tagName, options);
    if (tagName === "script") {
      const originalSrcSetter = Object.getOwnPropertyDescriptor(HTMLScriptElement.prototype, "src").set;
      Object.defineProperty(el, "src", {
        set(value) {
          // Look up the data URI by the chunk name
          const keys = Array.from(dataMap.keys());
          const key = keys.find(k => k.endsWith(value) || k.endsWith("/" + value));
          if (key) {
            const dataUri = dataMap.get(key);
            originalSrcSetter.call(this, dataUri);
          } else {
            originalSrcSetter.call(this, value);
          }
        },
        get() {
          return this.getAttribute("src");
        },
        configurable: true
      });
    }
    return el;
  };
  }

        // Patch fetch()
        const originalFetch = window.fetch;
        function normalizeUrl(url) {
          let href = typeof url === "string" ? url : url.href;

          try {
            const u = new URL(href);

            const segments = u.pathname.split('/').filter(Boolean);

            if (segments.length === 1) {
              return segments[0];
            }

            return href;
          } catch (e) {
            return href;
          }
        }
        // Helper to resolve redirect target if any
        function resolveBlobRedirect(url) {
          try {
            url = normalizeUrl(url);
            const absUrl = new URL(url, base).href;
            for (const [key, dataUrl] of dataMap.entries()) {
              const absUrlNoQuery = String(absUrl).split(/[?#]/)[0];
              const pathToUploadedBlob = base.substring(0, base.lastIndexOf('/')) + "/" + key;
              if (
                absUrlNoQuery === pathToUploadedBlob ||
                (
                  isLocal &&
                  absUrlNoQuery.endsWith(".wasm") &&
                  absUrlNoQuery.endsWith(key.replace(/^.*[\\/]/, ''))
                )
              ) {
                console.log("ðŸ”€ Redirecting fetch from", absUrl, "â†’", dataUrl);
                return dataUrl;
              }
            }
          } catch (e) {
            console.warn("URL resolution failed for", url, e);
          }
          return null;
        }

        // Patch fetch safely
        window.fetch = function(input, init) {
          let url = input;

          // If input is a Request object, preserve it
          if (input instanceof Request) {
            const redirected = resolveBlobRedirect(input.url);
            if (redirected) {
              // Clone request with new URL but same properties
              const newRequest = new Request(redirected, input);
              return originalFetch.call(this, newRequest, init);
            }
            return originalFetch.call(this, input, init);
          }

          // If input is a string
          const redirected = resolveBlobRedirect(input);
          if (redirected) {
            url = redirected;
          }

          return originalFetch.call(this, url, init);
        };
      })();
    `;
    const baseElement = document.createElement('base');
    baseElement.href =  document.location.href;
    doc.body.appendChild(baseElement);
    doc.body.appendChild(finalizeScript);

    // Now serialize the modified document to text
    const finalHtml = '<!doctype html>\n' + doc.documentElement.outerHTML;

    log('Launching rewritten page into iframe...');
    iframe.srcdoc = finalHtml;

    log('Done. If SWFs do not start automatically, check console in the preview iframe (right-click â†’ Inspect).');
  }

  runBtn.addEventListener('click', () => {
    runBtn.disabled = true;
    buildAndLaunch().catch(err => {
      log('Error:', err && err.message ? err.message : String(err));
    }).finally(() => {
      runBtn.disabled = false;
    });
  });

})();
</script>
</body>
</html>
